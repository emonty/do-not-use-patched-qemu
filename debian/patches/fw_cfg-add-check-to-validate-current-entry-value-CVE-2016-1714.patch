Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: fw_cfg: add check to validate current entry value
From: Prasad J Pandit <pjp@fedoraproject.org>
Message-Id: <1452060985-25843-1-git-send-email-ppandit@redhat.com>
To: Stefan Weil <sw@weilnetz.de>
Cc: Peter Maydell <peter.maydell@linaro.org>,
 Prasad J Pandit <pjp@fedoraproject.org>,
 Qemu devel <qemu-devel@nongnu.org>,
 Donghai Zdh <donghai.zdh@alibaba-inc.com>
Date: Wed,  6 Jan 2016 11:46:25 +0530

When processing firmware configurations, an OOB r/w access occurs
if 's->cur_entry' is set to be invalid(FW_CFG_INVALID=0xffff).
Add a check to validate 's->cur_entry' to avoid such access.

Reported-by: Donghai Zdh <donghai.zdh@alibaba-inc.com>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
---
 hw/nvram/fw_cfg.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index 68eff77..e73c0fb 100644
#--- a/hw/nvram/fw_cfg.c
#+++ b/hw/nvram/fw_cfg.c
# this code is not present in 2.5
#@@ -233,12 +233,15 @@ static void fw_cfg_reboot(FWCfgState *s)
# static void fw_cfg_write(FWCfgState *s, uint8_t value)
# {
#     int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);
#-    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
#+    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :
#+                     &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
# 
#     trace_fw_cfg_write(s, value);
# 
#-    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && e->callback &&
#-        s->cur_offset < e->len) {
#+    if (s->cur_entry & FW_CFG_WRITE_CHANNEL
#+        && e != NULL
#+        && e->callback
#+        && s->cur_offset < e->len) {
#         e->data[s->cur_offset++] = value;
#         if (s->cur_offset == e->len) {
#             e->callback(e->callback_opaque, e->data);
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -267,7 +270,8 @@ static int fw_cfg_select(FWCfgState *s, uint16_t key)
 static uint8_t fw_cfg_read(FWCfgState *s)
 {
     int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);
-    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
+    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :
+                     &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
     uint8_t ret;
 
     if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)
